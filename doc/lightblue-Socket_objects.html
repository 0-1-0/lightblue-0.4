<html>
<head>
<title>Socket objects</title>
	<link rel='stylesheet' href='shortdoc.css' />
</head>
<body>

<h2 class='moduletitle'>package <span class='modulename'><a href='index.html'>lightblue</a>:</span></h2>
<div class='class'>

<h3 class='classtitle'>Socket objects</h3>
<pre class='doc'>    A Bluetooth socket object has the same interface as a socket object from 
    the Python standard library &lt;socket&gt; module. It also uses the same 
    exceptions, raising socket.error for general errors and socket.timeout for 
    timeout errors.

    Note that L2CAP sockets are not available on Python For Series 60, and
    only L2CAP client sockets are supported on Mac OS X and Linux.

    A simple client socket example:
<pre class='python'><code>        <span class="interpreter">&gt;&gt;&gt;</span> <span class='keyword'>from</span> lightblue <span class='keyword'>import</span> *
        <span class="interpreter">&gt;&gt;&gt;</span> s = socket()        <span class='comment'># or socket(L2CAP) to create an L2CAP socket</span>
        <span class="interpreter">&gt;&gt;&gt;</span> s.connect((<span class='string'>"00:12:2c:45:8a:7b"</span>, <span class='number'>5</span>))
        <span class="interpreter">&gt;&gt;&gt;</span> s.send(<span class='string'>"hello"</span>)
        <span class='number'>5</span>
        <span class="interpreter">&gt;&gt;&gt;</span> s.close()</code></pre>
    A simple server socket example:
<pre class='python'><code>        <span class="interpreter">&gt;&gt;&gt;</span> <span class='keyword'>from</span> lightblue <span class='keyword'>import</span> *
        <span class="interpreter">&gt;&gt;&gt;</span> s = socket()
        <span class="interpreter">&gt;&gt;&gt;</span> s.bind((<span class='string'>""</span>, <span class='number'>0</span>))
        <span class="interpreter">&gt;&gt;&gt;</span> s.listen(<span class='number'>1</span>)
        <span class="interpreter">&gt;&gt;&gt;</span> advertise(<span class='string'>"My RFCOMM Service"</span>, s, RFCOMM)
        <span class="interpreter">&gt;&gt;&gt;</span> conn, addr = s.accept()
        <span class="interpreter">&gt;&gt;&gt;</span> <span class='keyword'>print</span> <span class='string'>"Connected by"</span>, addr
        Connected by (<span class='string'>'00:0D:93:19:C8:68'</span>, <span class='number'>5</span>)
        <span class="interpreter">&gt;&gt;&gt;</span> conn.recv(<span class='number'>1024</span>)
        <span class='string'>"hello"</span>
        <span class="interpreter">&gt;&gt;&gt;</span> conn.close()
        <span class="interpreter">&gt;&gt;&gt;</span> s.close()</code></pre></pre>
<div id='methods' class='section'>
<h2 class='sectiontitle'>Methods</h2>
<div id='functionlinks'>
<ul>
<li><a href='#accept'><strong>accept</strong>(<span class='sig'></span>)
</a></li>
<li><a href='#bind'><strong>bind</strong>(<span class='sig'>address</span>)
</a></li>
<li><a href='#close'><strong>close</strong>(<span class='sig'></span>)
</a></li>
<li><a href='#connect'><strong>connect</strong>(<span class='sig'>address</span>)
</a></li>
<li><a href='#connect_ex'><strong>connect_ex</strong>(<span class='sig'>address</span>)
</a></li>
<li><a href='#dup'><strong>dup</strong>(<span class='sig'></span>)
</a></li>
<li><a href='#fileno'><strong>fileno</strong>(<span class='sig'></span>)
</a></li>
<li><a href='#getpeername'><strong>getpeername</strong>(<span class='sig'></span>)
</a></li>
<li><a href='#getsockname'><strong>getsockname</strong>(<span class='sig'></span>)
</a></li>
<li><a href='#getsockopt'><strong>getsockopt</strong>(<span class='sig'>level, option[, bufsize]</span>)
</a></li>
<li><a href='#gettimeout'><strong>gettimeout</strong>(<span class='sig'></span>)
</a></li>
<li><a href='#listen'><strong>listen</strong>(<span class='sig'>backlog</span>)
</a></li>
<li><a href='#makefile'><strong>makefile</strong>(<span class='sig'>[mode[, bufsize]]</span>)
</a></li>
<li><a href='#recv'><strong>recv</strong>(<span class='sig'>bufsize[, flags]</span>)
</a></li>
<li><a href='#recvfrom'><strong>recvfrom</strong>(<span class='sig'>bufsize[, flags]</span>)
</a></li>
<li><a href='#send'><strong>send</strong>(<span class='sig'>data[, flags]</span>)
</a></li>
<li><a href='#sendall'><strong>sendall</strong>(<span class='sig'>data[, flags]</span>)
</a></li>
<li><a href='#sendto'><strong>sendto</strong>(<span class='sig'>data[, flags], address</span>)
</a></li>
<li><a href='#setblocking'><strong>setblocking</strong>(<span class='sig'>flag</span>)
</a></li>
<li><a href='#setsockopt'><strong>setsockopt</strong>(<span class='sig'>level, option, value</span>)
</a></li>
<li><a href='#settimeout'><strong>settimeout</strong>(<span class='sig'>timeout</span>)
</a></li>
<li><a href='#shutdown'><strong>shutdown</strong>(<span class='sig'>how</span>)
</a></li>
</ul>
</div>
<a name='accept'></a><h4 class='methodtitle'>accept(<span class='sig'></span>)
</h4>

<pre class='doc'>
    accept() -&gt; (socket object, address info)
    
    Wait for an incoming connection. Return a new socket representing the
    connection, and the address of the client. For RFCOMM sockets, the address
    info is a pair (hostaddr, channel).
    
    The socket must be bound and listening before calling this method.</pre>
<a name='bind'></a><h4 class='methodtitle'>bind(<span class='sig'>address</span>)
</h4>

<pre class='doc'>
    bind(address)
    
    Bind the socket to a local address. For RFCOMM sockets, the address is a
    pair (host, channel); the host must refer to the local host. 
    
    A port value of 0 binds the socket to a dynamically assigned port.
    (Note that on Mac OS X, the port value must always be 0.)
    
    The socket must not already be bound.</pre>
<a name='close'></a><h4 class='methodtitle'>close(<span class='sig'></span>)
</h4>

<pre class='doc'>
    close()
    
    Close the socket.  It cannot be used after this call.</pre>
<a name='connect'></a><h4 class='methodtitle'>connect(<span class='sig'>address</span>)
</h4>

<pre class='doc'>
    connect(address)
    
    Connect the socket to a remote address. The address should be a 
    (host, channel) pair for RFCOMM sockets, and a (host, PSM) pair for L2CAP
    sockets.
    
    The socket must not be already connected.</pre>
<a name='connect_ex'></a><h4 class='methodtitle'>connect_ex(<span class='sig'>address</span>)
</h4>

<pre class='doc'>
    connect_ex(address) -&gt; errno
    
    This is like connect(address), but returns an error code instead of raising 
    an exception when an error occurs.</pre>
<a name='dup'></a><h4 class='methodtitle'>dup(<span class='sig'></span>)
</h4>

<pre class='doc'>
    dup() -&gt; socket object
    
    Returns a new socket object connected to the same system resource.</pre>
<a name='fileno'></a><h4 class='methodtitle'>fileno(<span class='sig'></span>)
</h4>

<pre class='doc'>
    fileno() -&gt; integer
    
    Return the integer file descriptor of the socket.
    
    Raises NotImplementedError on Mac OS X and Python For Series 60.</pre>
<a name='getpeername'></a><h4 class='methodtitle'>getpeername(<span class='sig'></span>)
</h4>

<pre class='doc'>
    getpeername() -&gt; address info 
    
    Return the address of the remote endpoint. The address info is a
    (host, channel) pair for RFCOMM sockets, and a (host, PSM) pair for L2CAP
    sockets.
    
    If the socket has not been connected, socket.error will be raised.</pre>
<a name='getsockname'></a><h4 class='methodtitle'>getsockname(<span class='sig'></span>)
</h4>

<pre class='doc'>
    getsockname() -&gt; address info
    
    Return the address of the local endpoint. The address info is a
    (host, channel) pair for RFCOMM sockets, and a (host, PSM) pair for L2CAP
    sockets.
    
    If the socket has not been connected nor bound, this returns the tuple
    ("00:00:00:00:00:00", 0).</pre>
<a name='getsockopt'></a><h4 class='methodtitle'>getsockopt(<span class='sig'>level, option[, bufsize]</span>)
</h4>

<pre class='doc'>
    getsockopt(level, option[, bufsize]) -&gt; value
    
    Get a socket option.  See the Unix manual for level and option.
    If a nonzero buffersize argument is given, the return value is a
    string of that length; otherwise it is an integer.
    
    Currently support for socket options are platform independent -- i.e. 
    depends on the underlying Series 60 or BlueZ socket options support. 
    The Mac OS X implementation currently does not support any options at
    all and automatically raises socket.error.</pre>
<a name='gettimeout'></a><h4 class='methodtitle'>gettimeout(<span class='sig'></span>)
</h4>

<pre class='doc'>
    gettimeout() -&gt; timeout
     
    Returns the timeout in floating seconds associated with socket 
    operations. A timeout of None indicates that timeouts on socket 
    operations are disabled.
    
    Currently not supported on Python For Series 60 implementation, which 
    will always return None.</pre>
<a name='listen'></a><h4 class='methodtitle'>listen(<span class='sig'>backlog</span>)
</h4>

<pre class='doc'>
    listen(backlog)
    
    Enable a server to accept connections. The backlog argument must be at
    least 1; it specifies the number of unaccepted connection that the system
    will allow before refusing new connections.
        
    The socket must not be already listening.
    
    Currently not implemented on Mac OS X.</pre>
<a name='makefile'></a><h4 class='methodtitle'>makefile(<span class='sig'>[mode[, bufsize]]</span>)
</h4>

<pre class='doc'>
    makefile([mode[, bufsize]]) -&gt; file object

    Returns a regular file object corresponding to the socket.  The mode
    and bufsize arguments are as for the built-in open() function.</pre>
<a name='recv'></a><h4 class='methodtitle'>recv(<span class='sig'>bufsize[, flags]</span>)
</h4>

<pre class='doc'>
    recv(bufsize[, flags]) -&gt; data
    
    Receive up to bufsize bytes from the socket.  For the optional flags
    argument, see the Unix manual.  When no data is available, block until
    at least one byte is available or until the remote end is closed.  When
    the remote end is closed and all data is read, return the empty string.
    
    Currently the flags argument has no effect on Mac OS X.</pre>
<a name='recvfrom'></a><h4 class='methodtitle'>recvfrom(<span class='sig'>bufsize[, flags]</span>)
</h4>

<pre class='doc'>
    recvfrom(bufsize[, flags]) -&gt; (data, address info)
    
    Like recv(buffersize, flags) but also return the sender's address info.</pre>
<a name='send'></a><h4 class='methodtitle'>send(<span class='sig'>data[, flags]</span>)
</h4>

<pre class='doc'>
    send(data[, flags]) -&gt; count
    
    Send a data string to the socket.  For the optional flags
    argument, see the Unix manual.  Return the number of bytes
    sent.
    
    The socket must be connected to a remote socket.
    
    Currently the flags argument has no effect on Mac OS X.</pre>
<a name='sendall'></a><h4 class='methodtitle'>sendall(<span class='sig'>data[, flags]</span>)
</h4>

<pre class='doc'>
    sendall(data[, flags])
 
    Send a data string to the socket.  For the optional flags
    argument, see the Unix manual.  This calls send() repeatedly
    until all data is sent.  If an error occurs, it's impossible
    to tell how much data has been sent.</pre>
<a name='sendto'></a><h4 class='methodtitle'>sendto(<span class='sig'>data[, flags], address</span>)
</h4>

<pre class='doc'>
    sendto(data[, flags], address) -&gt; count
    
    Like send(data, flags) but allows specifying the destination address.
    For RFCOMM sockets, the address is a pair (hostaddr, channel).</pre>
<a name='setblocking'></a><h4 class='methodtitle'>setblocking(<span class='sig'>flag</span>)
</h4>

<pre class='doc'>
    setblocking(flag)
     
    Set the socket to blocking (flag is true) or non-blocking (false).
    setblocking(True) is equivalent to settimeout(None);
    setblocking(False) is equivalent to settimeout(0.0).
    
    Initially a socket is in blocking mode. In non-blocking mode, if a 
    socket operation cannot be performed immediately, socket.error is raised.</pre>
<a name='setsockopt'></a><h4 class='methodtitle'>setsockopt(<span class='sig'>level, option, value</span>)
</h4>

<pre class='doc'>
    setsockopt(level, option, value)
     
    Set a socket option.  See the Unix manual for level and option.
    The value argument can either be an integer or a string.
    
    Currently support for socket options are platform independent -- i.e. 
    depends on the underlying Series 60 or BlueZ socket options support. 
    The Mac OS X implementation currently does not support any options at
    all and automatically raise socket.error.</pre>
<a name='settimeout'></a><h4 class='methodtitle'>settimeout(<span class='sig'>timeout</span>)
</h4>

<pre class='doc'>
    settimeout(timeout)
     
    Set a timeout on socket operations.  'timeout' can be a float,
    giving in seconds, or None.  Setting a timeout of None disables
    the timeout feature and is equivalent to setblocking(1).
    Setting a timeout of zero is the same as setblocking(0).    
    
    If a timeout is set, the connect, accept, send and receive operations will 
    raise socket.timeout if a timeout occurs.
    
    Raises NotImplementedError on Python For Series 60.</pre>
<a name='shutdown'></a><h4 class='methodtitle'>shutdown(<span class='sig'>how</span>)
</h4>

<pre class='doc'>
    shutdown(how)
     
    Shut down the reading side of the socket (flag == socket.SHUT_RD), the 
    writing side of the socket (flag == socket.SHUT_WR), or both ends 
    (flag == socket.SHUT_RDWR).</pre>
</div>


</div>
</body></html>